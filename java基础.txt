成员变量和局部变量
1.作用范围
成员变量作用于整个类中
局部变量作用于函数中,或者语句中
2.在内存中的位置
成员变量:在堆内存中,因为对象的存在,才在内存中存在
局部变量:存在栈内存中


私有是封装的一种表现形式

封装原则:
将不需要对外提供的内容都隐藏起来
把属性都隐藏,提供公共方法对其访问

对象一建立,就调用与之对应的构造函数
构造函数的作用可以用于给对象进行初始化
构造函数小细节
当一个类中没有定义构造函数时,那么系统会默认给该类加入一个空参数的构造函数
当在类中自定义了构造函数后,默认的构造函数就没有了

构造代码块
作用:给对象进行初始化
对象一建立就运行,而且优先于构造函数运行
和构造函数的区别:
构造代码块是给所有对象进行统一初始化
而构造函数是给对应的对象初始化的
{

}


this:就代表本类对象
this代表它所在函数所属对象的引用
简单说:哪个对象在调用this所在的函数
this就代表哪个对象

this的应用:当定义类中功能时,该函数内部要用到调用该函数
的对象时,这时用this来表示这个对象
但凡本类功能内部使用了本类对象,都用this表示

this语句只能定义在构造函数的第一行因为初始化要先执行


主函数:是一个特殊的函数.作为程序的入口,可以被jvm调用
主函数的定义
public:代表着该函数访问权限是最大的
static:代表主函数随着类的加载就已经存在了
void:主函数没有具体的返回值
main:不是关键字,但是是一个特殊的单词,可以被jvm识别
(String[] args) 函数的参数,参数类型是一个数组,该数组中的元素是字符串,字符串类型是数组
主函数是固定格式的:jvm识别

jvm在调用主函数时,传入的是new String[0];

什么时候使用静态?
要从两方面下手:
因为静态修饰的内容有成员变量和函数
什么时候定义静态变量(类变量)呢

当对象中出现共享数据时,该数据被静态所修饰
对象中的特有数据要定义成非静态存在于堆内存中


什么时候定义静态函数呢?

当功能内部没有访问非静态数据(对象的特有数据),
那么该功能可以定义成静态的.

每一个应用程序中都有共性的功能
可以将这些功能进行抽取,独立封装
以便复用

虽然可以通过建立ArrayTool的对象使用这些工具方法,对数组进行操作
发现了问题
1.对象是用于封装数据的,可是ArrayTool对象并未封装特有数据
2.操作数据的每一个方法都没有用到
ArrayTool对象中的特有数据
这时就考虑,让程序更严谨,是不需要对象的
可以将ArrayTool中的方法都定义成static的直接通过类名调用即可

将方法都静态后,可以方便于使用,但是该类还是可以被其他程序建立对象的
为了更为严谨,强制让该类不能建立对象
可以通过将构造函数私有化完成

一个类中默认会有一个空参数的构造函数
这个默认的构造函数的权限和所属类一致
如果类被public修饰,那么默认的构造函数也带public
修饰符
如果类没有被public修饰,那么默认的构造函数也没有public修饰

默认构造函数的权限是随着类的变化而变化的

/**
静态代码块
格式:
static
{
	静态代码块中的执行语句
}
特点:随着类的加载而执行,只执行一次.
用于给类进行初始化的.并优先于主函数
*/

Person p = new Person("zhangsan",20);
该句话都做了哪些事情？
1.因为new用到了Person.class,所以会先找到Person.class文件并加载到内存中
2.执行该类中的static代码块，如果有的话，给Person.class类进行初始化
3.在堆内存中开辟空间，分配内存地址
4.在堆内存中建立对象的特有属性。并进行默认初始化
5.对属性进行显示初始化
6.对对象进行构造代码块初始化
7.对对象进行对应的构造函数初始化
8.将内存地址赋给栈内存中的p变量




